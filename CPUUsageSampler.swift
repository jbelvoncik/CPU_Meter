//
//  CPUUsageSampler.swift
//  CPU_Meter
//
//  Reports both overall and per-core CPU utilization using Mach host APIs.
//  Generated by ChatGPT (GPT-5) for Jozef Belvončik — educational use.
//
//  © 2025 Jozef Belvončik MIT License
//

import Foundation
import Combine

final class CPUUsageSampler: ObservableObject {

    /// Overall CPU utilization 0–1
    @Published var overall: Double = 0

    /// Per-core utilization array 0–1
    @Published var cores: [Double] = []

    private var prev: [[UInt32]] = []
    private var timer: Timer?

    init(interval: TimeInterval = 1.0) {
        sampleOnce()
        timer = .scheduledTimer(withTimeInterval: interval, repeats: true) { [weak self] _ in
            self?.sampleOnce()
        }
        RunLoop.main.add(timer!, forMode: .common)
    }

    deinit { timer?.invalidate() }

    private func sampleOnce() {
        var n: natural_t = 0
        var arr: processor_info_array_t?
        var cnt: mach_msg_type_number_t = 0

        guard host_processor_info(mach_host_self(),
                                  PROCESSOR_CPU_LOAD_INFO,
                                  &n,
                                  &arr,
                                  &cnt) == KERN_SUCCESS,
              let base = arr else { return }

        let stride = Int(CPU_STATE_MAX)
        let buf = UnsafeBufferPointer(start: base, count: Int(cnt))
        let coresCount = Int(n)
        if prev.count != coresCount { prev = Array(repeating: [0,0,0,0], count: coresCount) }

        var perCore: [Double] = []
        var totalBusy = 0.0, totalAll = 0.0

        for i in 0..<coresCount {
            let o = i * stride
            let u = UInt32(buf[o+Int(CPU_STATE_USER)])
            let s = UInt32(buf[o+Int(CPU_STATE_SYSTEM)])
            let n = UInt32(buf[o+Int(CPU_STATE_NICE)])
            let id = UInt32(buf[o+Int(CPU_STATE_IDLE)])

            let du = Double(u &- prev[i][0])
            let ds = Double(s &- prev[i][1])
            let dn = Double(n &- prev[i][2])
            let di = Double(id &- prev[i][3])

            let busy = du + ds + dn
            let all = busy + di
            let util = all > 0 ? busy / all : 0
            perCore.append(util)
            totalBusy += busy
            totalAll += all
            prev[i] = [u,s,n,id]
        }

        vm_deallocate(mach_task_self_,
                      vm_address_t(bitPattern: base),
                      vm_size_t(cnt)*vm_size_t(MemoryLayout<integer_t>.stride))

        DispatchQueue.main.async {
            self.cores = perCore
            self.overall = totalAll > 0 ? totalBusy / totalAll : 0
        }
    }
}
