//
//  CPU_MeterApp.swift
//  CPU_Meter
//
//  This project was not written by a human developer.
//  All code and build scripts were generated by ChatGPT (GPT-5)
//  at the request of Jozef Belvončik.
//  Repository purpose: educational & experimental.
//
//  © 2025 Jozef Belvončik  MIT License
//

import SwiftUI
import AppKit
import Darwin

// MARK: - CPUUsageSampler
/// Periodically queries the macOS Mach kernel for per-CPU usage ticks.
/// Converts tick deltas into a single averaged utilization value (0–1 range).
final class CPUUsageSampler: ObservableObject {

    /// Overall CPU utilization averaged across all logical cores.
    @Published var overall: Double = 0

    /// Cached previous tick counts (user, system, nice, idle) for delta computation.
    private var previous: [[UInt32]] = []

    /// Periodic timer driving the sampling loop.
    private var timer: Timer?

    /// Initializes the sampler and starts a repeating timer.
    /// - Parameter interval: Sampling interval in seconds (default 1 s).
    init(interval: TimeInterval = 1.0) {
        sampleOnce()
        timer = .scheduledTimer(withTimeInterval: interval, repeats: true) { [weak self] _ in
            self?.sampleOnce()
        }
        RunLoop.main.add(timer!, forMode: .common)
    }

    deinit { timer?.invalidate() }

    /// Reads kernel CPU tick counters and computes utilization.
    private func sampleOnce() {
        var cpuCount: natural_t = 0
        var infoArray: processor_info_array_t?
        var infoCount: mach_msg_type_number_t = 0

        guard host_processor_info(mach_host_self(),
                                  PROCESSOR_CPU_LOAD_INFO,
                                  &cpuCount,
                                  &infoArray,
                                  &infoCount) == KERN_SUCCESS,
              let base = infoArray else { return }

        let stride = Int(CPU_STATE_MAX)
        let buffer = UnsafeBufferPointer(start: base, count: Int(infoCount))
        if previous.count != Int(cpuCount) {
            previous = Array(repeating: [0, 0, 0, 0], count: Int(cpuCount))
        }

        var sumBusy = 0.0, sumTotal = 0.0
        for i in 0..<Int(cpuCount) {
            let o = i * stride
            let u = UInt32(buffer[o + Int(CPU_STATE_USER)])
            let s = UInt32(buffer[o + Int(CPU_STATE_SYSTEM)])
            let n = UInt32(buffer[o + Int(CPU_STATE_NICE)])
            let id = UInt32(buffer[o + Int(CPU_STATE_IDLE)])

            // Tick deltas since previous sample.
            let du = Double(u &- previous[i][0])
            let ds = Double(s &- previous[i][1])
            let dn = Double(n &- previous[i][2])
            let di = Double(id &- previous[i][3])

            let busy = du + ds + dn
            let total = busy + di
            sumBusy += busy
            sumTotal += total

            previous[i] = [u, s, n, id]
        }

        // Release Mach-allocated memory.
        vm_deallocate(mach_task_self_,
                      vm_address_t(bitPattern: base),
                      vm_size_t(infoCount) * vm_size_t(MemoryLayout<integer_t>.stride))

        // Publish averaged utilization to the SwiftUI view.
        DispatchQueue.main.async {
            self.overall = sumTotal > 0 ? sumBusy / sumTotal : 0
        }
    }
}

// MARK: - OverlayWindow
/// Transparent always-on-top frameless window used for the floating overlay.
/// Does not become key window to avoid stealing focus from user applications.
final class OverlayWindow: NSWindow {
    init(view: NSView) {
        super.init(contentRect: NSRect(x: 100, y: 100, width: 180, height: 80),
                   styleMask: [.borderless],
                   backing: .buffered,
                   defer: false)
        isOpaque = false
        backgroundColor = .clear
        level = .floating
        isMovableByWindowBackground = true
        collectionBehavior = [.canJoinAllSpaces]
        contentView = view
    }

    /// Prevents focus stealing (expected overlay behaviour).
    override var canBecomeKey: Bool { false }
}

// MARK: - OverlayView
/// SwiftUI front-end showing the current CPU load as a text label.
/// Future versions will add GPU and ANE metrics.
struct OverlayView: View {
    @StateObject var cpu = CPUUsageSampler()
    var body: some View {
        Text(String(format: "CPU %.0f%%", cpu.overall * 100))
            .font(.system(size: 20, weight: .bold, design: .rounded))
            .foregroundColor(.white)
            .padding(20)
            .background(.black.opacity(0.35))
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
    }
}

// MARK: - App entry
/// Application entry point.  Creates and shows the overlay window.
@main
struct CPU_MeterApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    var body: some Scene { Settings { EmptyView() } } // No Dock settings window
}

// MARK: - AppDelegate
/// Handles macOS-level window creation and application lifecycle.
final class AppDelegate: NSObject, NSApplicationDelegate {
    private var window: OverlayWindow?
    func applicationDidFinishLaunching(_ note: Notification) {
        let host = NSHostingView(rootView: OverlayView())
        window = OverlayWindow(view: host)
        // orderFrontRegardless avoids focus warnings in console
        window?.orderFrontRegardless()
        NSApp.setActivationPolicy(.accessory)
    }
}
